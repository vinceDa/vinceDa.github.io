---
categories: [algorithm]
tags: [algorithm]
---

字符串匹配这个功能，我相信对于每个开发工程师来说是再熟悉不过了。无论是Ctrl+F搜索内容还是在编程语言中调用函数（Java、JS的indexOf()、Python的find()），它们的实现都是依赖于字符串匹配算法。

字符串匹配算法很多。根据它们的难易程度和匹配模式，我将常见的几种算法分类如下：

![](https://raw.githubusercontent.com/vinceDa/image-host/main/img/1629740009970-23a8807d-a09f-479c-b48a-2b80ebd8d1a5.png)

今天我们先来学习入门级别的两种算法：BF、RK算法。

# BF算法

讲到字符串匹配，如果要我们自己去实现的话，我觉得最容易想到的思路就是BF算法。不信你可以先自己构思一下然后带着自己的实现思路继续往下看。

BF算法的全称是Brute Force，中文名叫暴力匹配算法，又称朴素匹配算法。从名字就可以看出来，这种算法的匹配方式很直接、简单，相对应的性能也不会很高。

在开始讲解这个算法之前，有两个概念需要理解下：**主串**和**模式串**。举个例子，我需要从abcdef中查找abc，那么主串就是abcdef，模式串就是abc。我们把主串的长度记作n，模式串的长度记作m，不难看出，n>m。

我们可以用一句话来总结BF算法的思想：模式串在下标i为[0, n-m+1]的范围内和主串进行匹配，如果匹配失败则向后移一位继续匹配，直到匹配成功或者下标超范围。如下图所示
![](https://raw.githubusercontent.com/vinceDa/image-host/main/img/1629740017085-78e857a7-832f-43e4-9b7a-ad790fe4f25f.jpeg)


从BF的算法思想和图中我们可以看出来，在极端情况下，主串和模式串需要匹配m*(n-m+1)次，所以BF算法的最坏时间复杂度为$O(nm)$ 。

虽然BF算法的时间复杂很高，但是在实际开发中它却是个比较常用的算法。这是为什么呢？我认为原因主要有两点。

1. 它和你一开始的想法是一样的吧！因为它足够简单，所以它的代码很容易实现并且容易维护，即使出现bug也不会出现需要找到特定的人才能解决的窘境。在我们的日常开发中，只要代码符合性能要求，那么它应该尽可能简单，这就是我们常说的[KISS(keep it simple, stupid)原则](https://baike.baidu.com/item/KISS%E5%8E%9F%E5%88%99/3242383)。
2. 我们日常开发中，主串和模式串的长度通常不会太长，而且每次匹配过程中，只要碰到某个字符不能匹配，匹配就可以终止了。并不是每次匹配都需要匹配m个字符。所以尽管理论上的最坏时间复杂度是$O(nm)$，但是它大概率是优于这个效率的。

所以，在绝大部分的开发场景下，BF算法已经足够用了。

# RK算法

我们之前提到，BF算法满足大部分的场景。那么，如果我们要追求更好的性能，有没有其他的算法可以使用呢？答案是肯定有，RK算法就是其中一种。

RK算法全称是Rabin-Karp算法，是用它的两位发明者Rabin和Karp的名字命名的。它的匹配思路和BF算法有点像，但是它引入了哈希算法，所以在我看来它是BF算法的升级版。

回顾下BF算法：模式串从主串下标[0, n-m+1]匹配，超出范围还没有匹配到则匹配失败。换言之，模式串需要和最多n-m+1个子串进行匹配。每次模式串和主串进行匹配时需要比对**每一个字符**，这是BF算法最耗性能的一个点，如果我们能对这个点进行优化的话，相信性能会好很多，RK算法也是这么做的。

RK算法的大致思路就是计算n-m+1个子串的每个子串的哈希值，然后用模式串的哈希值和子串的哈希值依次比对，如果哈希值相等则说明已匹配（先不考虑哈希冲突）。由于哈希值是整型，所以比对的速度很快。

![](https://raw.githubusercontent.com/vinceDa/image-host/main/img/1629740027748-d4c73eca-01df-4593-844c-fd2e13d43e1b.jpeg)

不过，通过哈希算法计算每个子串的哈希值的时候，我们需要通过遍历主串的方式去拿到每个子串。这样虽然子串和模式串比对的效率提升了，但是对于整体的效率而言并没有什么帮助。那么应该通过什么方式去拿到每个子串的哈希值呢？

这就是RK算法的精髓所在了，它的哈希算法设计的极为巧妙。举个例子，假设我们要匹配的字符串的字符集只包含K个字符，那么我们就用K进制数去表示每一个子串，然后将这个K进制数转化成十进制当作这个子串的哈希值。比如我们要计算的字符串中只包含a~z的小写字母，那么我们就用二十六进制来表示字符串，其中分别对应的数字为0~25。具体计算过程如图所示。

![](https://raw.githubusercontent.com/vinceDa/image-host/main/img/1629740075947-6b17995a-6a3a-4575-88e4-829d64304583.jpeg)


这种哈希算法有一个特点，就是它的相邻位置的哈希值计算公式是有联系的。具体是什么联系，大家可以用下图的例子来自己推演一下。

![](https://raw.githubusercontent.com/vinceDa/image-host/main/img/1629740089588-0c482309-8723-4252-85fa-68109108de57.jpeg)

从图中我们可以看出，s[i - 1]和s[i]的计算公式是有交集的，也就是说我们可以通过s[i-1]的哈希值快速找到s[i]的哈希值。下面是我的推导过程

![](https://raw.githubusercontent.com/vinceDa/image-host/main/img/1629740093031-9ad0d024-4de1-419f-b1c6-714a5b2770f3.jpeg)

从我们的最终公式可以看到，我们使用了$26^{m-1}$。我们可以先将这一部分的计算存储下来，以m-1为key存入数组中。这样的话可以在公式计算中快速找到它的值，从而省略了这一部分的计算时间，如下图所示。

![](https://raw.githubusercontent.com/vinceDa/image-host/main/img/1629740098338-012ef629-0f6d-43d3-95e3-5aa3c55571c3.jpeg)

我们设计的哈希算法到这儿已经基本完成了，但是还是存在几个问题。

1.  这时候为了让计算出的哈希值落在整型范围内，我们可以牺牲一下子串哈希值的唯一性，允许一定的哈希冲突，比如通过十进制、十六进制等方式去实现。 
> 我们刚才设计的哈希算法是没有哈希冲突的，因为我们是基于进制去表示一个字符串的，子串中的字符的位置不同计算出来的哈希值也就不同。这样会带来个问题就是当模式串很长的时候计算出来的哈希值有可能很大，甚至会超出整型范围，这种情况应该如何解决呢？

2.  其实很简单，当出现哈希冲突的时候，直接将当前的模式串和子串进行字符比对，如果匹配不成功则继续往后走。 
> 新的解决方案解决哈希值过大的问题，那它带来的哈希冲突又该如何解决呢？


以上就是RK算法的核心思想了。接下来我们来分析一下它的时间复杂度吧。

RK算法由两部分组成：

第一部分是遍历一次主串计算每个子串的哈希值，这一部分的时间复杂度为$O(n)$；

第二部分比对模式串和子串的哈希值，每次比对的时间复杂度为$O(1)$，所以它的时间复杂度也为$O(n)$；

所以，RK算法的时间复杂度就是$O(n)$。

如果存在大量的哈希冲突，在极端情况下，RK算法会出现每次比较的时候哈希值都相等然后需要去匹配字符串，这时候它的时间复杂度会退化成$O(nm)$；但是这个概率是很低的，只要我们哈希算法设计的好，冲突是不会很多的，所以RK算法的效率也是会比BF算法高的。

# 总结

我们今天学习了字符串匹配的两种入门级别的算法：BF和RK算法。

BF算法很简单，将模式串和主串的所有子串进行匹配，看是否能匹配成功。所以，它的时间复杂度很高，是$O(nm)$，但是正是因为它的简单粗暴，所以在小规模字符串匹配的场景中使用频率很高；

RK算法针对字符串比较耗时的缺点进行改造，将字符串的匹配改为哈希值的比对；时间复杂度为$o(n)$；当出现哈希冲突时，时间复杂度会退化；极端情况下会退化成$O(nm)$。不过绝大部分情况下，RK算法的效率还是远大于BF算法的。

# 参考资料

[王争 —— 数据结构与算法之美](https://time.geekbang.org/column/article/71187)

[算法4](https://item.jd.com/11098789.html)
